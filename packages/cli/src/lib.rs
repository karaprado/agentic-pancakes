// WASM Library exports for ARW CLI
// This module provides JavaScript-accessible functions when compiled to WASM

use serde::{Deserialize, Serialize};
use serde_json::Value;

// Re-export validators and generators for internal use
pub mod validators {
    pub mod llms_txt;
}

pub mod generators {
    pub mod llms_txt;
}

// Parser modules for testing and internal use
pub mod parsers;

// Utils module requires native dependencies (tracing, tokio)
#[cfg(feature = "native")]
pub mod utils;

// WASM-specific module
#[cfg(feature = "wasm")]
pub mod wasm;

// Re-export WASM functions at the root level for proper module initialization
// Note: We avoid glob re-exports to prevent ambiguity with NAPI exports
#[cfg(feature = "wasm")]
pub use wasm::{
    validate_manifest_wasm,
    validate_manifest_json_wasm,
    generate_llms_txt_wasm,
    check_compatibility_wasm,
    wasm_init,
};

// NAPI-RS-specific module (Node.js native bindings)
#[cfg(feature = "napi")]
pub mod napi;

// Re-export NAPI functions selectively to avoid conflicts
// The NAPI module exports are handled through #[napi] macro
// so we don't need to re-export them here

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ArwConfig {
    pub site_name: String,
    pub homepage: String,
    pub contact: String,
    pub profile: String,
    pub description: Option<String>,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ValidationResult {
    pub valid: bool,
    pub errors: Vec<ValidationErrorData>,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ValidationErrorData {
    pub path: String,
    pub message: String,
}

// Helper function for internal use and testing
pub fn validate_manifest(manifest: &Value) -> Result<Vec<ValidationErrorData>, Box<dyn std::error::Error>> {
    let errors = validators::llms_txt::validate_manifest(manifest)?;

    Ok(errors
        .into_iter()
        .map(|e| ValidationErrorData {
            path: e.path,
            message: e.message,
        })
        .collect())
}

/// Escape single quotes for YAML single-quoted strings
fn escape_yaml_single_quote(s: &str) -> String {
    s.replace('\'', "''")
}

/// Internal function to generate llms.txt content
pub fn generate_llms_txt_content(config: &ArwConfig) -> Result<String, Box<dyn std::error::Error>> {
    let mut output = String::new();

    output.push_str("# Agent-Ready Web Discovery Manifest\n");
    output.push_str("# Generated by ARW CLI\n\n");

    output.push_str("version: 1.0\n");
    output.push_str(&format!("profile: {}\n\n", config.profile));

    output.push_str("site:\n");
    output.push_str(&format!("  name: '{}'\n", escape_yaml_single_quote(&config.site_name)));

    if let Some(desc) = &config.description {
        output.push_str(&format!("  description: '{}'\n", escape_yaml_single_quote(desc)));
    }

    output.push_str(&format!("  homepage: '{}'\n", escape_yaml_single_quote(&config.homepage)));
    output.push_str(&format!("  contact: '{}'\n\n", escape_yaml_single_quote(&config.contact)));

    output.push_str("content: []\n\n");

    output.push_str("policies:\n");
    output.push_str("  training:\n");
    output.push_str("    allowed: false\n");
    output.push_str("  inference:\n");
    output.push_str("    allowed: true\n");
    output.push_str("  attribution:\n");
    output.push_str("    required: true\n");

    Ok(output)
}

// Helper function for internal use and testing
pub fn generate_llms_txt(config: &ArwConfig) -> Result<String, Box<dyn std::error::Error>> {
    generate_llms_txt_content(config)
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_generate_minimal_manifest() {
        let config = ArwConfig {
            site_name: "Test Site".to_string(),
            homepage: "https://example.com".to_string(),
            contact: "ai@example.com".to_string(),
            profile: "ARW-1".to_string(),
            description: None,
        };

        let result = generate_llms_txt(&config);
        assert!(result.is_ok());

        let content = result.unwrap();
        assert!(content.contains("version: 1.0"));
        assert!(content.contains("profile: ARW-1"));
        assert!(content.contains("name: 'Test Site'"));
        assert!(content.contains("homepage: 'https://example.com'"));
        assert!(content.contains("contact: 'ai@example.com'"));
    }

    #[test]
    fn test_validate_minimal_manifest() {
        let manifest_str = r#"
version: 1.0
profile: ARW-1
site:
  name: Test Site
  homepage: https://example.com
  contact: ai@example.com
policies:
  training:
    allowed: false
  inference:
    allowed: true
  attribution:
    required: true
"#;

        let manifest: Value = serde_yaml::from_str(manifest_str).unwrap();
        let result = validate_manifest(&manifest);

        assert!(result.is_ok());
        let errors = result.unwrap();

        // Debug: print errors if any
        if !errors.is_empty() {
            eprintln!("Validation errors found:");
            for error in &errors {
                eprintln!("  - {}: {}", error.path, error.message);
            }
        }

        assert_eq!(errors.len(), 0, "Should have no validation errors");
    }

    #[test]
    fn test_validate_invalid_profile() {
        let manifest_str = r#"
version: 1.0
profile: INVALID
site:
  name: Test Site
  homepage: https://example.com
  contact: ai@example.com
policies:
  training:
    allowed: false
  inference:
    allowed: true
  attribution:
    required: true
"#;

        let manifest: Value = serde_yaml::from_str(manifest_str).unwrap();
        let result = validate_manifest(&manifest);

        assert!(result.is_ok());
        let errors = result.unwrap();
        assert!(!errors.is_empty(), "Should have validation errors");
        assert!(
            errors.iter().any(|e| e.path == "profile"),
            "Should have error for profile field"
        );
    }

    #[test]
    fn test_validate_missing_required_fields() {
        let manifest_str = r#"
version: 1.0
profile: ARW-1
"#;

        let manifest: Value = serde_yaml::from_str(manifest_str).unwrap();
        let result = validate_manifest(&manifest);

        assert!(result.is_ok());
        let errors = result.unwrap();
        assert!(!errors.is_empty(), "Should have validation errors");

        // Check for missing site
        assert!(
            errors.iter().any(|e| e.path.starts_with("site")),
            "Should have error for missing site"
        );

        // Check for missing policies
        assert!(
            errors.iter().any(|e| e.path.starts_with("policies")),
            "Should have error for missing policies"
        );
    }
}
