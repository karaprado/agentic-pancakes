use anyhow::{Context, Result};
use std::fs;
use std::path::Path;

/// Site information for llms.txt generation
pub struct SiteInfo {
    pub name: String,
    pub description: String,
    pub homepage: String,
    pub contact: String,
}

/// Policy information for llms.txt generation
pub struct PolicyInfo {
    pub training_allowed: bool,
    pub inference_allowed: bool,
    pub attribution_required: bool,
}

pub fn generate<P: AsRef<Path>>(
    site_path: P,
    site_info: &SiteInfo,
    policy_info: &PolicyInfo,
) -> Result<()> {
    let content = format_llms_txt(site_info, policy_info);
    let output_path = site_path.as_ref().join("llms.txt");

    fs::write(&output_path, content)
        .with_context(|| format!("Failed to write llms.txt to {:?}", output_path))?;

    Ok(())
}

fn format_llms_txt(site: &SiteInfo, policy: &PolicyInfo) -> String {
    let mut output = String::new();

    // Header
    output.push_str("# Agent-Ready Web Discovery File\n");
    output.push_str("# Generated by ARW CLI\n");
    output.push_str("# Learn more: https://github.com/agent-ready-web/agent-ready-web\n\n");

    // Version and profile
    output.push_str("version: 1.0\n");
    output.push_str("profile: ARW-1\n\n");

    // Site information
    output.push_str("site:\n");
    output.push_str(&format!("  name: \"{}\"\n", escape_yaml(&site.name)));
    output.push_str(&format!(
        "  description: \"{}\"\n",
        escape_yaml(&site.description)
    ));
    output.push_str(&format!("  homepage: \"{}\"\n", site.homepage));
    output.push_str(&format!("  contact: \"{}\"\n", site.contact));
    output.push_str("\n");

    // Content section with example
    output.push_str("# Machine-Readable Content\n");
    output.push_str("# List your pages with their machine views and priorities\n");
    output.push_str("content:\n");
    output.push_str("  - url: /\n");
    output.push_str("    machine_view: /index.llm.md\n");
    output.push_str("    purpose: homepage\n");
    output.push_str("    priority: high\n");
    output.push_str("\n");

    // Policies
    output.push_str("# Usage Policies\n");
    output.push_str("policies:\n");
    output.push_str("  training:\n");
    output.push_str(&format!("    allowed: {}\n", policy.training_allowed));
    output.push_str("  inference:\n");
    output.push_str(&format!("    allowed: {}\n", policy.inference_allowed));
    output.push_str("  attribution:\n");
    output.push_str(&format!("    required: {}\n", policy.attribution_required));

    output
}

fn escape_yaml(s: &str) -> String {
    s.replace('\\', "\\\\").replace('"', "\\\"")
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_format_llms_txt() {
        let site = SiteInfo {
            name: "Test Site".to_string(),
            description: "A test site".to_string(),
            homepage: "https://example.com".to_string(),
            contact: "test@example.com".to_string(),
        };
        let policy = PolicyInfo {
            training_allowed: false,
            inference_allowed: true,
            attribution_required: true,
        };
        let output = format_llms_txt(&site, &policy);

        assert!(output.contains("version: 1.0"));
        assert!(output.contains("site:"));
        assert!(output.contains("policies:"));
        assert!(output.contains("profile: ARW-1"));
    }

    #[test]
    fn test_escape_yaml() {
        assert_eq!(escape_yaml("test\"quote"), "test\\\"quote");
        assert_eq!(escape_yaml("test\\slash"), "test\\\\slash");
    }
}
