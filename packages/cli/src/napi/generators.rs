// NAPI-RS generation functions
// Provides high-performance manifest and content generation for Node.js

#[cfg(feature = "napi")]
use napi::bindgen_prelude::*;
#[cfg(feature = "napi")]
use napi_derive::napi;

/// Configuration for generating an ARW manifest
#[cfg(feature = "napi")]
#[napi(object)]
pub struct ManifestConfig {
    /// Site name
    pub site_name: String,
    /// Homepage URL
    pub homepage: String,
    /// Contact email for AI interactions
    pub contact: String,
    /// ARW profile (e.g., "ARW-1", "ARW-2", "ARW-3")
    pub profile: String,
    /// Optional site description
    pub description: Option<String>,
}

/// Generate an llms.txt manifest from configuration
///
/// # Arguments
/// * `config` - ManifestConfig with site information
///
/// # Returns
/// String containing the generated YAML manifest
#[cfg(feature = "napi")]
#[napi]
pub fn generate_manifest(config: ManifestConfig) -> Result<String> {
    let arw_config = crate::ArwConfig {
        site_name: config.site_name,
        homepage: config.homepage,
        contact: config.contact,
        profile: config.profile,
        description: config.description,
    };

    generate_llms_txt_content(&arw_config)
        .map_err(|e| Error::new(Status::GenericFailure, format!("{}", e)))
}


/// Internal function to generate llms.txt content
fn generate_llms_txt_content(config: &crate::ArwConfig) -> std::result::Result<String, Box<dyn std::error::Error>> {
    let mut output = String::new();

    output.push_str("# Agent-Ready Web Discovery Manifest\n");
    output.push_str("# Generated by ARW CLI (NAPI-RS)\n\n");

    output.push_str("version: 1.0\n");
    output.push_str(&format!("profile: {}\n\n", config.profile));

    output.push_str("site:\n");
    output.push_str(&format!("  name: '{}'\n", config.site_name));

    if let Some(desc) = &config.description {
        output.push_str(&format!("  description: '{}'\n", desc));
    }

    output.push_str(&format!("  homepage: '{}'\n", config.homepage));
    output.push_str(&format!("  contact: '{}'\n\n", config.contact));

    output.push_str("content: []\n\n");

    output.push_str("policies:\n");
    output.push_str("  training:\n");
    output.push_str("    allowed: false\n");
    output.push_str("  inference:\n");
    output.push_str("    allowed: true\n");
    output.push_str("  attribution:\n");
    output.push_str("    required: true\n");

    Ok(output)
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_generate_llms_txt_content() {
        let config = crate::ArwConfig {
            site_name: "Test Site".to_string(),
            homepage: "https://example.com".to_string(),
            contact: "ai@example.com".to_string(),
            profile: "ARW-1".to_string(),
            description: Some("A test site".to_string()),
        };

        let result = generate_llms_txt_content(&config);
        assert!(result.is_ok());

        let content = result.unwrap();
        assert!(content.contains("version: 1.0"));
        assert!(content.contains("profile: ARW-1"));
        assert!(content.contains("name: 'Test Site'"));
        assert!(content.contains("description: 'A test site'"));
        assert!(content.contains("Generated by ARW CLI (NAPI-RS)"));
    }
}
